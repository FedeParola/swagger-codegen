{{>licenseInfo}}

{{#models}}{{#model}}
#include "{{classname}}.h"
{{^vendorExtensions.x-parent}}
#include "{{classname}}_dp.h"

{{classname}}::{{classname}}({{#vars}}{{#vendorExtensions.x-is-key}}const {{{datatype}}} {{{name}}}, {{/vendorExtensions.x-is-key}}{{/vars}}const {{classname}}Schema &schema, IOModuleType type): IOModule(name, generate_code(), type){
  {{#vars}}
  {{^isNotContainer}}
  for(auto &i : schema.{{getter}}())
      add{{nameInCamelCase}}(i);
  {{/isNotContainer}}
  {{#isNotContainer}} 
  {{^vendorExtensions.x-is-key}}
  {{^isReadOnly}}
  if(schema.{{name}}IsSet())
  {{#isPrimitiveType}}
      {{setter}}(schema.{{getter}}());
  {{/isPrimitiveType}}
  {{^isPrimitiveType}}
      add{{nameInCamelCase}}(schema.{{getter}}());
  {{/isPrimitiveType}}
  {{/isReadOnly}}
  {{/vendorExtensions.x-is-key}}
  {{/isNotContainer}}
  {{/vars}}   

}
{{/vendorExtensions.x-parent}}

{{#vendorExtensions.x-parent}}
{{classname}}:{{classname}}({{{this}}} &parent, {{#vendorExtensions.x-classname-inherited}}{{this}} &p, {{/vendorExtensions.x-classname-inherited}}const {{classname}}Schema &schema): parent_(parent) { }
{{/vendorExtensions.x-parent}}

{{classname}}::~{{classname}}() { }

void {{classname}}::update(const {{classname}}Schema &schema) { 
  //throw std::runtime_error("Method not implemented");
  {{#vars}}
  {{^isNotContainer}}
  for(auto &i : schema.{{getter}}()){ 
      {{#vendorExtensions.x-key-list}}
      auto &{{varName}} = i.{{getter}}();
      {{/vendorExtensions.x-key-list}}
      auto m = get{{nameInCamelCase}}({{#vendorExtensions.x-key-list}}{{varName}}{{^lastKey}}, {{/lastKey}}{{/vendorExtensions.x-key-list}});
      m->update(i);
  }
  {{/isNotContainer}}
  {{#isNotContainer}}
  {{^vendorExtensions.x-is-key}}
  {{^isReadOnly}}
  if(schema.{{name}}IsSet())
  {{#isPrimitiveType}}
      {{setter}}(schema.{{getter}}());
  {{/isPrimitiveType}}
  {{^isPrimitiveType}}
      auto &m = {{getter}}();
      m->update(schema);
  {{/isPrimitiveType}}
  {{/isReadOnly}}
  {{/vendorExtensions.x-is-key}}
  {{/isNotContainer}}
  {{/vars}}
}

{{classname}}Schema {{classname}}::toSchema(){
  {{classname}}Schema schema;
  
  {{#vars}}
  {{#isNotContainer}}
  {{#isPrimitiveType}}
  schema.{{setter}}({{getter}}());
  {{/isPrimitiveType}}
  {{/isNotContainer}}
  {{/vars}}
  
  //I don't know how to generate code to particular element (for example portsAccess and portsTrunk)
  
  return schema;
}

{{#vendorExtensions.x-parent}}
void {{classname}}::create({{{this}}} &parent, const {{classname}}Schema &schema){
  throw std::runtime_error("Method not implemented");
}

std::shared_ptr<{{classname}}> {{classname}}::get({{{this}}} &parent{{#vars}}{{#vendorExtensions.x-is-key}}, const {{{datatype}}} &{{{name}}}{{/vendorExtensions.x-is-key}}{{/vars}}){
  throw std::runtime_error("Method not implemented");
}

void {{classname}}::remove({{{this}}} &parent{{#vars}}{{#vendorExtensions.x-is-key}}, const {{{datatype}}} &{{{name}}}{{/vendorExtensions.x-is-key}}{{/vars}}){
  throw std::runtime_error("Method not implemented");
}

{{#vendorExtensions.x-is-list}}
std::vector<std::shared_ptr<{{classname}}>> {{classname}}::get({{vendorExtensions.x-parent}} &parent){
  throw std::runtime_error("Method not implemented");
}

void {{classname}}::remove({{vendorExtensions.x-parent}} &parent){
  throw std::runtime_error("Method not implemented");
}
{{/vendorExtensions.x-is-list}}
{{/vendorExtensions.x-parent}}


{{#vars}}
{{^isNotContainer}}
std::shared_ptr<{{complexType}}> {{classname}}::get{{nameInCamelCase}}({{#vendorExtensions.x-key-list}}const {{type}} &{{varName}}{{^lastKey}}, {{/lastKey}}{{/vendorExtensions.x-key-list}}){
  return {{complexType}}::get(*this, {{#vendorExtensions.x-key-list}}{{varName}}{{^lastKey}}, {{/lastKey}}{{/vendorExtensions.x-key-list}});
}

std::vector<std::shared_ptr<{{complexType}}>> {{classname}}::getAll{{nameInCamelCase}}(){
  return {{complexType}}::get(*this);
}

void {{classname}}::add{{nameInCamelCase}}(const {{complexType}}Schema &conf){
  {{complexType}}::create(*this, conf);
}

void {{classname}}::del{{nameInCamelCase}}({{#vendorExtensions.x-key-list}}const {{type}} &{{varName}}{{^lastKey}}, {{/lastKey}}{{/vendorExtensions.x-key-list}}){
  {{complexType}}::remove(*this, {{#vendorExtensions.x-key-list}}{{varName}}{{^lastKey}}, {{/lastKey}}{{/vendorExtensions.x-key-list}});
}

void {{classname}}::delAll{{nameInCamelCase}}(){
  {{complexType}}::remove(*this);
}

{{/isNotContainer}}
{{#isNotContainer}}

{{#isPrimitiveType}}
{{{datatype}}} {{classname}}::{{getter}}(){
  throw std::runtime_error("Method not implemented");
}

{{^vendorExtensions.x-is-key}}
{{^isReadOnly}}
void {{classname}}::{{setter}}({{{datatype}}} &value){
  throw std::runtime_error("Method not implemented");
}

{{/isReadOnly}}
{{/vendorExtensions.x-is-key}}
{{/isPrimitiveType}}

{{^isPrimitiveType}}
std::shared_ptr<{{complexType}}> {{classname}}::get{{nameInCamelCase}}(){
  return {{complexType}}::get(*this);
}

{{^vendorExtensions.x-is-key}}
{{^isReadOnly}}
void {{classname}}::add{{nameInCamelCase}}(const {{complexType}}Schema &value){
  {{complexType}}::create(*this, value); 
}

void {{classname}}::del{{nameInCamelCase}}(){
  {{complexType}}::remove(*this);
}

{{/isReadOnly}}
{{/vendorExtensions.x-is-key}}
{{/isPrimitiveType}}
{{/isNotContainer}}
{{#isEnum}}

std::string {{classname}}::enum_to_string({{classname}}{{name}} value){
  switch(value){
      {{#allowableValues.values}}
      case {{classname}}{{name}}::{{value}}:
          return "{{stringValue}}";
      {{/allowableValues.values}}
      default:
          throw std::runtime_error("Bad {{classname}} {{name}}");
  }
}

{{classname}}{{name}} {{classname}}::string_to_enum(const std::string &str){
  switch(str){
      {{#allowableValues.values}}
      case "{{stringValue}}":
          return {{classname}}{{name}}::{{value}};
      {{/allowableValues.values}}
      default:
          throw std::runtime_error("{{classname}} {{name}} is invalid");
  }
}
{{/isEnum}}
{{/vars}}

{{/model}}{{/models}}
