{{>licenseInfo}}

//Modify these methods with your own implementation

{{#models}}{{#model}}
#include "{{classname}}.h"
{{#vendorExtensions.x-root-object}}
#include "{{vendorExtensions.x-root-object}}.h"
{{/vendorExtensions.x-root-object}}
{{^vendorExtensions.x-parent}}
#include "{{classname}}_dp.h"

{{classname}}::{{classname}}({{#vars}}{{#vendorExtensions.x-is-key}}const {{{datatype}}} {{{name}}}, {{/vendorExtensions.x-is-key}}{{/vars}}const {{classname}}JsonObject &conf, IOModuleType type)
                             : IOModule(name, generate_code(), type, conf.getIovnetLoglevel()) {
  logger()->set_pattern("[%Y-%m-%d %H:%M:%S.%e] [{{classname}}] [%n] [%l] %v");
  logger()->info("Creating {{classname}} instance");
  {{#vars}}{{^isNotContainer}}
  add{{nameInCamelCase}}List(conf.{{getter}}());{{/isNotContainer}}{{#isNotContainer}}{{^vendorExtensions.x-is-key}}{{^isReadOnly}}{{^vendorExtensions.x-is-required}}{{^vendorExtensions.x-has-default-value}}
  if(conf.{{name}}IsSet()) { {{/vendorExtensions.x-has-default-value}}{{/vendorExtensions.x-is-required}}{{#isPrimitiveType}}{{^vendorExtensions.x-is-iomodule-debug}}
    {{setter}}(conf.{{getter}}());{{/vendorExtensions.x-is-iomodule-debug}}{{/isPrimitiveType}}{{^isPrimitiveType}}
    auto value = conf.{{getter}}();{{#vendorExtensions.x-key-list}}
    {{type}} {{varName}}_ = value.{{getter}}();{{/vendorExtensions.x-key-list}}
    add{{nameInCamelCase}}({{#vendorExtensions.x-key-list}}{{varName}}, {{/vendorExtensions.x-key-list}}conf.{{getter}}());{{/isPrimitiveType}}{{^vendorExtensions.x-is-required}}{{^vendorExtensions.x-has-default-value}}
  } {{/vendorExtensions.x-has-default-value}}{{/vendorExtensions.x-is-required}}{{/isReadOnly}}{{/vendorExtensions.x-is-key}}
  {{/isNotContainer}}{{/vars}}   
}
{{/vendorExtensions.x-parent}}

{{#vendorExtensions.x-parent}}
{{classname}}::{{classname}}({{{this}}} &parent, {{#vendorExtensions.x-classname-inherited}}{{this}} &p, {{/vendorExtensions.x-classname-inherited}}const {{classname}}JsonObject &conf): parent_(parent){{#vendorExtensions.x-classname-inherited}}, {{this}}(p){{/vendorExtensions.x-classname-inherited}} { 
  logger()->info("Creating {{classname}} instance");
}
{{/vendorExtensions.x-parent}}

{{classname}}::~{{classname}}() { }

void {{classname}}::update(const {{classname}}JsonObject &conf) {
  //This method updates all the object/parameter in {{classname}} object specified in the conf JsonObject.
  //You can modify this implementation.
  {{#vars}}
  {{^vendorExtensions.x-is-key}}{{^isReadOnly}}
  if(conf.{{name}}IsSet()) { {{^isNotContainer}}
    for(auto &i : conf.{{getter}}()){ {{#vendorExtensions.x-key-list}}
      auto {{varName}} = i.{{getter}}();{{/vendorExtensions.x-key-list}}
      auto m = get{{nameInCamelCase}}({{#vendorExtensions.x-key-list}}{{varName}}{{^lastKey}}, {{/lastKey}}{{/vendorExtensions.x-key-list}});
      m->update(i);
    }{{/isNotContainer}}{{#isNotContainer}}{{#isPrimitiveType}}
    {{setter}}(conf.{{getter}}());{{/isPrimitiveType}}{{^isPrimitiveType}}
    auto m = {{getter}}();
    m->update(conf.{{getter}}());{{/isPrimitiveType}}{{/isNotContainer}}
  }{{/isReadOnly}}{{/vendorExtensions.x-is-key}}
  {{/vars}}
}

{{classname}}JsonObject {{classname}}::toJsonObject(){
  {{classname}}JsonObject conf;
  
  {{#vars}}
  {{#isNotContainer}}{{#isPrimitiveType}}
  conf.{{setter}}({{getter}}());{{/isPrimitiveType}}{{^isPrimitiveType}}
  conf.{{setter}}({{getter}}()->toJsonObject());{{/isPrimitiveType}}
  {{/isNotContainer}}{{^isNotContainer}}
  {{#vendorExtensions.x-is-port-class}}
  for(auto &i : {{getter}}List()){
    conf.add{{complexType}}(i->toJsonObject());
  }{{/vendorExtensions.x-is-port-class}}{{^vendorExtensions.x-is-port-class}}
  //Remove comments when you implement all sub-methods
  //for(auto &i : {{getter}}List()){
  //  conf.add{{complexType}}(i->toJsonObject());
  //}{{/vendorExtensions.x-is-port-class}}
  {{/isNotContainer}}
  {{/vars}}
  
  return conf;
}

{{^vendorExtensions.x-parent}}
std::string {{classname}}::generate_code(){
  return {{classVarName}}_code;
}

std::vector<std::string> {{classname}}::generate_code_vector(){
  throw std::runtime_error("Method not implemented");
}

void {{classname}}::packet_in(iovnet::service::Port &port, iovnet::service::PacketInMetadata &md, const std::vector<uint8_t> &packet){
  logger()->info("Packet received from port {0}", port.name());
}

{{/vendorExtensions.x-parent}}{{#vendorExtensions.x-parent}}
void {{classname}}::create({{{this}}} &parent, {{#vendorExtensions.x-key-list}}const {{{type}}} &{{{varName}}}, {{/vendorExtensions.x-key-list}}const {{classname}}JsonObject &conf){

  //This method creates the actual {{classname}} object given thee key param. 
  //Please remember to call here the create static method for all sub-objects of {{classname}}.
  
  {{#vendorExtensions.x-is-port-class}}
  if (parent.ports_.count(name) != 0) {
    throw std::runtime_error("port already exists");
  }

  auto p = parent.IOModule::add_port(name);
  std::unordered_map<std::string, {{classname}}>::iterator iter;
  bool inserted;

  std::tie(iter, inserted) = parent.ports_.emplace(std::piecewise_construct,
                                                   std::forward_as_tuple(name),
                                                   std::forward_as_tuple(parent, p, conf));
  //logger()->info("New port create with name {0}", name);
  {{/vendorExtensions.x-is-port-class}}
  {{^vendorExtensions.x-is-port-class}}
  throw std::runtime_error("[{{classname}}]: Method create not implemented");
  {{/vendorExtensions.x-is-port-class}}
}

std::shared_ptr<{{classname}}> {{classname}}::getEntry({{{this}}} &parent, {{#vendorExtensions.x-key-list}}const {{{type}}} &{{{varName}}}{{^lastKey}}, {{/lastKey}}{{/vendorExtensions.x-key-list}}){
  //This method retrieves the pointer to {{classname}} object specified by its keys.
  {{#vendorExtensions.x-is-port-class}}
  //logger()->info("Called getEntry with name: {0}", name);
  return std::shared_ptr<{{classname}}>(&parent.ports_.at(name), []({{classname}}*){});
  {{/vendorExtensions.x-is-port-class}}
  {{^vendorExtensions.x-is-port-class}}
  throw std::runtime_error("[{{classname}}]: Method getEntry not implemented");
  {{/vendorExtensions.x-is-port-class}}
}

void {{classname}}::removeEntry({{{this}}} &parent, {{#vendorExtensions.x-key-list}}const {{{type}}} &{{{varName}}}{{^lastKey}}, {{/lastKey}}{{/vendorExtensions.x-key-list}}){
  //This method removes the single {{classname}} object specified by its keys.
  //Remember to call here the remove static method for all-sub-objects of {{classname}}.
  {{#vendorExtensions.x-is-port-class}}
  parent.IOModule::remove_port(name);
  parent.ports_.erase(name);
  {{/vendorExtensions.x-is-port-class}}
  {{^vendorExtensions.x-is-port-class}}
  throw std::runtime_error("[{{classname}}]: Method removeEntry not implemented");
  {{/vendorExtensions.x-is-port-class}}
}

{{#vendorExtensions.x-is-list}}
std::vector<std::shared_ptr<{{classname}}>> {{classname}}::get({{vendorExtensions.x-parent}} &parent){
  //This methods get the pointers to all the {{classname}} objects in {{vendorExtensions.x-parent}}.
  {{#vendorExtensions.x-is-port-class}}
  std::vector<std::shared_ptr<{{classname}}>> ports_vect;
  for(auto &it : parent.ports_)
    ports_vect.push_back({{classname}}::getEntry(parent, it.first));

  return ports_vect;
  {{/vendorExtensions.x-is-port-class}}
  {{^vendorExtensions.x-is-port-class}}
  throw std::runtime_error("[{{classname}}]: Method get not implemented");
  {{/vendorExtensions.x-is-port-class}}
}

void {{classname}}::remove({{vendorExtensions.x-parent}} &parent){
  //This method removes all {{classname}} objects in {{vendorExtensions.x-parent}}.
  //Remember to call here the remove static method for all-sub-objects of {{classname}}.
  {{#vendorExtensions.x-is-port-class}}
  for(auto &it : parent.ports_) {
    int port_id = it.second.index();
    {{classname}}::removeEntry(parent, it.second.name());
  }
  {{/vendorExtensions.x-is-port-class}}
  {{^vendorExtensions.x-is-port-class}}
  throw std::runtime_error("[{{classname}}]: Method remove not implemented");
  {{/vendorExtensions.x-is-port-class}}
}
{{/vendorExtensions.x-is-list}}
{{/vendorExtensions.x-parent}}
{{#vars}}
{{^vendorExtensions.x-has-default-impl}}{{#isNotContainer}}{{#isPrimitiveType}}
{{{datatype}}} {{classname}}::{{getter}}(){
  //This method retrieves the {{name}} value.
  throw std::runtime_error("[{{classname}}]: Method {{getter}} not implemented");
}
{{^vendorExtensions.x-is-key}}{{^isReadOnly}}
void {{classname}}::{{setter}}(const {{{datatype}}} &value){
  //This method set the {{name}} value.
  throw std::runtime_error("[{{classname}}]: Method {{setter}} not implemented");
}
{{/isReadOnly}}{{/vendorExtensions.x-is-key}}{{/isPrimitiveType}}{{/isNotContainer}}{{/vendorExtensions.x-has-default-impl}}
{{/vars}}

{{#vendorExtensions.x-has-yang-actions}}
{{#vendorExtensions.x-yang-actions}}
{{#x-yang-action-has-output}}{{x-yang-action-output-object}}JsonObject{{/x-yang-action-has-output}}{{^x-yang-action-has-output}}void{{/x-yang-action-has-output}} {{classname}}::{{x-yang-action-name-lower-camelcase}}({{#x-yang-action-has-input}}{{x-yang-action-input-object}}JsonObject input{{/x-yang-action-has-input}}) {
  throw std::runtime_error("[{{classname}}]: Method {{x-yang-action-name-lower-camelcase}} not implemented");
}
{{/vendorExtensions.x-yang-actions}}
{{/vendorExtensions.x-has-yang-actions}}

{{#vendorExtensions.x-parent}}
std::shared_ptr<spdlog::logger> {{classname}}::logger() {
  return parent_.logger();
}
{{/vendorExtensions.x-parent}}

{{/model}}{{/models}}
